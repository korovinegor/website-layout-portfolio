// Test users array
var testusers = [
    {
        "username": "Georgiana",
        "bestScore": 4747
    },
    {
        "username": "Eldon",
        "bestScore": 2902
    },
    {
        "username": "Carroll",
        "bestScore": 1519
    },
    {
        "username": "Willow",
        "bestScore": 4249
    },
    {
        "username": "Carlo",
        "bestScore": 1529
    },
    {
        "username": "Scottie",
        "bestScore": 351
    },
    {
        "username": "Kenna",
        "bestScore": 411
    },
    {
        "username": "Clementina",
        "bestScore": 3667
    },
    {
        "username": "Eriberto",
        "bestScore": 4560
    },
    {
        "username": "Phyllis",
        "bestScore": 292
    },
    {
        "username": "Donnie",
        "bestScore": 2330
    },
    {
        "username": "Sadie",
        "bestScore": 965
    },
    {
        "username": "Maxwell",
        "bestScore": 798
    },
    {
        "username": "Bethany",
        "bestScore": 1972
    },
    {
        "username": "Jaron",
        "bestScore": 4316
    },
    {
        "username": "Fletcher",
        "bestScore": 2820
    },
    {
        "username": "Letitia",
        "bestScore": 2299
    },
    {
        "username": "Bria",
        "bestScore": 898
    },
    {
        "username": "Danielle",
        "bestScore": 4115
    },
    {
        "username": "Mckenna",
        "bestScore": 2749
    },
    {
        "username": "Prince",
        "bestScore": 545
    },
    {
        "username": "Kian",
        "bestScore": 2479
    },
    {
        "username": "Zack",
        "bestScore": 3065
    },
    {
        "username": "Foster",
        "bestScore": 4211
    },
    {
        "username": "Ryan",
        "bestScore": 2729
    },
    {
        "username": "Berta",
        "bestScore": 297
    },
    {
        "username": "Fredy",
        "bestScore": 3663
    },
    {
        "username": "Kiana",
        "bestScore": 2602
    },
    {
        "username": "Myrna",
        "bestScore": 4414
    },
    {
        "username": "Jadon",
        "bestScore": 4556
    },
    {
        "username": "Crawford",
        "bestScore": 4162
    },
    {
        "username": "Everett",
        "bestScore": 1761
    },
    {
        "username": "Hosea",
        "bestScore": 1644
    },
    {
        "username": "Claire",
        "bestScore": 1786
    },
    {
        "username": "Earl",
        "bestScore": 2269
    },
    {
        "username": "Janice",
        "bestScore": 442
    },
    {
        "username": "Oswald",
        "bestScore": 2413
    },
    {
        "username": "Estelle",
        "bestScore": 194
    },
    {
        "username": "Clark",
        "bestScore": 4070
    },
    {
        "username": "Noble",
        "bestScore": 2708
    },
    {
        "username": "Jaunita",
        "bestScore": 919
    },
    {
        "username": "Caleb",
        "bestScore": 2651
    },
    {
        "username": "Mara",
        "bestScore": 3939
    },
    {
        "username": "Rhea",
        "bestScore": 3550
    },
    {
        "username": "Isidro",
        "bestScore": 3206
    },
    {
        "username": "Anabelle",
        "bestScore": 1508
    },
    {
        "username": "Kenneth",
        "bestScore": 1045
    },
    {
        "username": "Jason",
        "bestScore": 3757
    },
    {
        "username": "Dalton",
        "bestScore": 2205
    },
    {
        "username": "Ramona",
        "bestScore": 1285
    },
    {
        "username": "Nicholas",
        "bestScore": 1183
    },
    {
        "username": "Claudie",
        "bestScore": 4458
    },
    {
        "username": "Renee",
        "bestScore": 595
    },
    {
        "username": "Jamil",
        "bestScore": 451
    },
    {
        "username": "Adelle",
        "bestScore": 1871
    },
    {
        "username": "Marilie",
        "bestScore": 1316
    },
    {
        "username": "Citlalli",
        "bestScore": 3137
    },
    {
        "username": "Lucious",
        "bestScore": 2294
    },
    {
        "username": "Juliana",
        "bestScore": 2380
    },
    {
        "username": "Winfield",
        "bestScore": 49
    },
    {
        "username": "Willa",
        "bestScore": 1426
    },
    {
        "username": "Ethelyn",
        "bestScore": 2551
    },
    {
        "username": "Elvera",
        "bestScore": 4285
    },
    {
        "username": "Vita",
        "bestScore": 2540
    },
    {
        "username": "Roger",
        "bestScore": 250
    },
    {
        "username": "Jeffery",
        "bestScore": 4333
    },
    {
        "username": "Reece",
        "bestScore": 4735
    },
    {
        "username": "Freeman",
        "bestScore": 1126
    },
    {
        "username": "Layne",
        "bestScore": 3152
    },
    {
        "username": "Melyna",
        "bestScore": 4897
    },
    {
        "username": "Jalen",
        "bestScore": 2576
    },
    {
        "username": "Florian",
        "bestScore": 3413
    },
    {
        "username": "Louie",
        "bestScore": 3133
    },
    {
        "username": "Cletus",
        "bestScore": 1156
    },
    {
        "username": "Amparo",
        "bestScore": 4413
    },
    {
        "username": "Aurore",
        "bestScore": 3054
    },
    {
        "username": "Vernice",
        "bestScore": 1347
    },
    {
        "username": "Caleb",
        "bestScore": 534
    },
    {
        "username": "Chris",
        "bestScore": 4405
    },
    {
        "username": "Jennings",
        "bestScore": 4192
    },
    {
        "username": "Waylon",
        "bestScore": 3330
    },
    {
        "username": "Allie",
        "bestScore": 4934
    },
    {
        "username": "Eveline",
        "bestScore": 633
    },
    {
        "username": "Linwood",
        "bestScore": 866
    },
    {
        "username": "Alisa",
        "bestScore": 1697
    },
    {
        "username": "Allison",
        "bestScore": 2535
    },
    {
        "username": "Rosendo",
        "bestScore": 950
    },
    {
        "username": "Adam",
        "bestScore": 4392
    },
    {
        "username": "Rita",
        "bestScore": 2628
    },
    {
        "username": "Alessia",
        "bestScore": 4992
    },
    {
        "username": "Katarina",
        "bestScore": 623
    },
    {
        "username": "Joy",
        "bestScore": 100
    },
    {
        "username": "Wilton",
        "bestScore": 1811
    },
    {
        "username": "Ruth",
        "bestScore": 893
    },
    {
        "username": "Maximillian",
        "bestScore": 4610
    },
    {
        "username": "Rudolph",
        "bestScore": 932
    },
    {
        "username": "Raphaelle",
        "bestScore": 501
    },
    {
        "username": "Arthur",
        "bestScore": 1506
    },
    {
        "username": "Regan",
        "bestScore": 1992
    },
    {
        "username": "Godfrey",
        "bestScore": 4945
    }
];
window.localStorage.setItem("users", JSON.stringify(testusers));

// Account variables
const usernameMaxLength = 16;
var currentUsername;


// Game varibales (time varibales use seconds)
// General
var isGameRunning = false;

// Game time
var gameTimeSpan = 0;
var gameTimeLeft = 0;
const gameMinusTime = 0.01;
var countGameTimeIntervalId = -1;

// Figure
var isMouseHoldOnSvg = false;
var maxPolygonVerticesCount = 3;
var polygonVertices = [];
var currentCutsPoints = [];
var currentCutsIntersectionsCount = 0;
var extraCutsCount = 0;
var requiredCutsCount = 1;
var requiredFiguresCount = 2;

// Score
var currentScore = 0;
var solutionPlusScore = 1;
var solutionPlusTime = 30;

// Page navigation variables
var currentPageId;


// Styling methods

function styleLeaderboard() {
    let tableHead = document.querySelector("#table-leaderboard>thead");
    let tableBody = document.querySelector("#table-leaderboard>tbody");
    let tableRow = document.getElementById("tablerow-currentusername");
    let tableBodyFirstChild = document.querySelector("#table-leaderboard>tbody>tr:first-child");

    const tableRowTop = tableRow.getBoundingClientRect().top;
    const tableRowBottom = tableRow.getBoundingClientRect().bottom;
    const tableBodyTop = tableBody.getBoundingClientRect().top;
    const tableBodyBottom = tableBody.getBoundingClientRect().bottom;
    tableRow.classList.toggle("tablerow-bordertop", tableRowBottom == tableBodyBottom);
    tableRow.classList.toggle("tablerow-borderbottom", tableRowBottom != tableBodyBottom);
    tableRow.classList.toggle("tablerow-shadowtop", tableRowBottom == tableBodyBottom);
    tableRow.classList.toggle("tablerow-shadowbottom", tableRowTop == tableBodyTop && tableRow != tableBodyFirstChild);
    tableHead.classList.toggle("tablerow-shadowbottom", tableBody.scrollTop > 0);
};

document.querySelector("#table-leaderboard>tbody").addEventListener("scroll", styleLeaderboard);


// Authorization methods

function enterUnderUsername(username) {
    let users = JSON.parse(window.localStorage.getItem("users"));
    isAccounted = false;
    for (let i = 0; i < users.length; i++) {
        if (users[i]["username"] == username) {
            isAccounted = true;
        }
    }

    if (!isAccounted) {
        users.push({
            "username": `${username}`,
            "bestScore": 0
        });
        window.localStorage.setItem("users", JSON.stringify(users));
    }

    currentUsername = username;
}

// Input username element
var inputTextUsername = document.getElementById("input-username");
inputTextUsername.max = usernameMaxLength;
inputTextUsername.addEventListener("input", (e) => {
    let input = e.target.value;
    if (input.length > usernameMaxLength) {
        e.target.value = input.slice(0, usernameMaxLength);
    }
});
inputTextUsername.addEventListener("keydown", (e) => {
    if (e.key == "Enter") {
        let input = e.target.value;
        if (input != "") {
            enterUnderUsername(input);
            goToPage("page-home");
            e.target.value = "";
        }
    }
});


// Game methods

function setDifficulty(difficulty) {
    switch (difficulty) {
        case "easy": {
            gameTimeSpan = 120;
            maxPolygonVerticesCount = 4;
            solutionPlusScore = 1;
            solutionPlusTime = 10;
            extraCutsCount = 2;
            break;
        }
        case "normal": {
            gameTimeSpan = 60;
            maxPolygonVerticesCount = 6;
            solutionPlusScore = 3;
            solutionPlusTime = 5;
            extraCutsCount = 1;
            break;
        }
        case "hard": {
            gameTimeSpan = 10;
            maxPolygonVerticesCount = 8;
            solutionPlusScore = 5;
            solutionPlusTime = 3;
            extraCutsCount = 0;
            break;
        }
    }
}

function updateLeaderboard() {

    // Get users array from local storage
    let users = JSON.parse(window.localStorage.getItem("users"));
    users.sort((a, b) => {
        return b["bestScore"] - a["bestScore"];
    });

    // Clear leaderboard
    let tableLeaderboard = document.querySelector("#table-leaderboard>tbody");
    tableLeaderboard.innerHTML = "";

    // Add rows to leaderboard
    for (let i = 0; i < users.length; i++) {
        let tableRow = document.createElement("tr");
        let tableCellPlace = document.createElement("td");
        let tableCellUsername = document.createElement("td");
        let tableCellBestScore = document.createElement("td");

        tableCellPlace.textContent = i + 1;
        tableCellUsername.textContent = users[i]["username"];
        tableCellBestScore.textContent = users[i]["bestScore"];
        tableCellBestScore.classList.add("text-score");

        if (users[i]["username"] == currentUsername) {
            tableRow.id = "tablerow-currentusername";
        }
        tableRow.appendChild(tableCellPlace);
        tableRow.appendChild(tableCellUsername);
        tableRow.appendChild(tableCellBestScore);

        tableLeaderboard.appendChild(tableRow);
    }

    // Clear scroll value and add style
    tableLeaderboard.scroll(0, 0);
    styleLeaderboard();

}

function countGameTime() {
    if (gameTimeLeft > gameTimeSpan) {
        gameTimeLeft = gameTimeSpan;
    }

    gameTimeLeft -= gameMinusTime;
    if (gameTimeLeft < 0) {
        gameTimeLeft = 0;
    }

    document.getElementById("text-time").textContent = Math.round(gameTimeLeft) + "Ñ";
    document.getElementById("block-time").style.width = `${gameTimeLeft / gameTimeSpan * 100}%`;

    if (gameTimeLeft == 0 && isGameRunning) {
        endGame();
    }
}

function updateFigureTask() {
    let svgFigure = document.getElementById("svg-figure");

    // Calculate required cuts and figures
    requiredCutsCount = Math.floor(Math.random() * 2) + 2;
    requiredFiguresCount = 1 + (1 + requiredCutsCount) / 2 * requiredCutsCount;
    requiredCutsCount += extraCutsCount;

    // Clear prevoius polygon vertices
    polygonVertices = [];

    // Create polygon vertices
    const triangleVerticesCount = 3;
    const polygonVerticesCount = Math.floor(Math.random() * (maxPolygonVerticesCount - triangleVerticesCount + 1) + triangleVerticesCount);
    const polygonRotation = Math.random() * 2 * Math.PI;
    for (let i = 0; i < polygonVerticesCount; i++) {
        const angle = 2 * Math.PI / polygonVerticesCount * i + polygonRotation;
        const x1 = 0;
        const y1 = -(Math.random() * 0.3 + 0.5);

        const containerRect = svgFigure.getBoundingClientRect();
        const scale = Math.min(containerRect.width, containerRect.height) / 2;
        const offset = { "x": containerRect.width / 2, "y": containerRect.height / 2 };
        let x2 = x1 * Math.cos(angle) - y1 * Math.sin(angle);
        let y2 = x1 * Math.sin(angle) + y1 * Math.cos(angle);

        x2 = Math.round(x2 * scale + offset["x"]);
        y2 = Math.round(y2 * scale + offset["y"]);
        polygonVertices.push({ "x": x2, "y": y2 });
    }

    // Clear svg content
    svgFigure.innerHTML = "";

    // Clear required cuts and figures text
    let textCuts = document.getElementById("text-cuts");
    let textFigures = document.getElementById("text-figures");
    textCuts.textContent = "--";
    textFigures.textContent = "--";

    // Add polygon to HTML
    let polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
    let polygonAttrPoints = "";
    for (let i = 0; i < polygonVertices.length; i++) {
        polygonAttrPoints += `${polygonVertices[i]["x"]},${polygonVertices[i]["y"]} `;
    }
    polygon.setAttribute("points", polygonAttrPoints);
    polygon.addEventListener("mousedown", svgFigureMouseDownHandler);
    polygon.addEventListener("mouseup", svgFigureMouseUpHandler);
    polygon.addEventListener("mousemove", svgFigureMouseMoveHandler);
    svgFigure.appendChild(polygon);

    // Add required cuts and figures to HTML
    textCuts.textContent = "0/" + requiredCutsCount;
    textFigures.textContent = "1/" + requiredFiguresCount;
}

// function scaleFromSvgContainerCenter(svgContainer, points, scale) {

//     // Translate points from svg container center to origin
//     for (let i = 0; i < points.length; i++) {
//         points[i]["x"] -= svgContainer.width / 2;
//         points[i]["y"] -= svgContainer.height / 2;
//     }

//     // Scale points
//     for (let i = 0; i < polygonVertices.length; i++) {
//         points[i]["x"] *= scale;
//         points[i]["y"] *= scale;
//     }

//     // Translate points from svg container origin to center
//     for (let i = 0; i < polygonVertices.length; i++) {
//         points[i]["x"] += svgContainer.width / 2;
//         points[i]["y"] += svgContainer.height / 2;
//     }

// }

// var windowSize = { "width": window.innerWidth, "height": window.innerHeight };
// window.addEventListener("resize", (e) => {
//     let newWindowSize = { "width": window.innerWidth, "height": window.innerHeight };
// });

function startGame() {
    isGameRunning = true

    currentScore = 0;
    document.getElementById("block-score").textContent = "0";

    updateFigureTask();

    gameTimeLeft = gameTimeSpan;
    countGameTime();
    countGameTimeIntervalId = setInterval(countGameTime, gameMinusTime * 1000);
}

function showGameResults() {
    let users = JSON.parse(window.localStorage.getItem("users"));
    let userIndex = 0;
    let bestScore = 0;
    for (let i = 0; i < users.length; i++) {
        if (users[i]["username"] == currentUsername) {
            userIndex = i;
            bestScore = users[i]["bestScore"];
            break;
        }
    }

    if (currentScore > bestScore) {
        bestScore = currentScore;
        users[userIndex]["bestScore"] = bestScore;
        window.localStorage.setItem("users", JSON.stringify(users));
    }

    document.getElementById("block-finalscore").textContent = currentScore;
    document.getElementById("block-bestscore").textContent = bestScore;
}

function clearGame() {
    clearInterval(countGameTimeIntervalId);
    currentCutsPoints = [];
    currentCutsIntersectionsCount = 0;
    currentScore = 0;
}

function endGame() {
    isGameRunning = false;

    showGameResults();
    clearGame();
    goToPage("page-gameover");
}

// If segments intersect, returns intersection point,
// otherwise returns null
function getIntersectionPoint(segment1, segment2) {
    const a = (segment1["y2"] - segment1["y1"]) / (segment1["x2"] - segment1["x1"]);
    const b = segment1["y1"] - a * segment1["x1"];
    const c = (segment2["y2"] - segment2["y1"]) / (segment2["x2"] - segment2["x1"]);
    const d = segment2["y1"] - c * segment2["x1"];

    let x0, y0;
    if (a == c || a == -c) {
        return null;
    }
    else {
        y0 = (a * d - b * c) / (a - c);
        x0 = (d - b) / (a - c);
    }

    const minX1 = Math.min(segment1["x1"], segment1["x2"]);
    const maxX1 = Math.max(segment1["x1"], segment1["x2"]);
    const minY1 = Math.min(segment1["y1"], segment1["y2"]);
    const maxY1 = Math.max(segment1["y1"], segment1["y2"]);

    const minX2 = Math.min(segment2["x1"], segment2["x2"]);
    const maxX2 = Math.max(segment2["x1"], segment2["x2"]);
    const minY2 = Math.min(segment2["y1"], segment2["y2"]);
    const maxY2 = Math.max(segment2["y1"], segment2["y2"]);

    if (x0 >= minX1 && x0 <= maxX1 && y0 >= minY1 && y0 <= maxY1 &&
        x0 >= minX2 && x0 <= maxX2 && y0 >= minY2 && y0 <= maxY2) {
        return { "x": x0, "y": y0 };
    }
    else {
        return null;
    }
}

function svgFigureMouseDownHandler(e) {
    if (!isMouseHoldOnSvg && isGameRunning) {
        isMouseHoldOnSvg = true;

        let target = e.target;
        while (target.id != "svg-figure") {
            target = target.parentNode;
        }

        const containerRect = target.getBoundingClientRect();
        const cursorRelativeX = e.clientX - containerRect.x;
        const cursorRelativeY = e.clientY - containerRect.y;
        let line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", cursorRelativeX);
        line.setAttribute("y1", cursorRelativeY);
        line.setAttribute("x2", cursorRelativeX);
        line.setAttribute("y2", cursorRelativeY);

        target.appendChild(line);
    }
};

function updateFigureTaskState() {

    // Count intersections count between last cut and prevoius cuts
    let lastCut = currentCutsPoints[currentCutsPoints.length - 1];
    for (let i = 0; i < currentCutsPoints.length - 1; i++) {
        if (getIntersectionPoint(lastCut, currentCutsPoints[i]) != null) {
            currentCutsIntersectionsCount += 1;
        }
    }

    // Compare current cuts and figures with required and take the following action
    let currentCutsCount = currentCutsPoints.length;
    let currentFiguresCount = 1 + currentCutsPoints.length + currentCutsIntersectionsCount;
    let textCuts = document.getElementById("text-cuts");
    let textFigures = document.getElementById("text-figures");
    if (currentCutsCount == requiredCutsCount && currentFiguresCount < requiredFiguresCount) {

        let lines = document.querySelectorAll("#svg-figure>line");
        for (let i = 0; i < lines.length; i++) {
            lines[i].remove();
        }

        currentCutsPoints = [];
        currentCutsIntersectionsCount = 0;

        textCuts.textContent = "0/" + requiredCutsCount;
        textFigures.textContent = "1/" + requiredFiguresCount;
    }
    else if (currentFiguresCount >= requiredFiguresCount) {
        currentScore += solutionPlusScore;
        document.getElementById("block-score").textContent = currentScore;

        gameTimeLeft += solutionPlusTime;
        countGameTime();

        currentCutsPoints = [];
        currentCutsIntersectionsCount = 0;

        updateFigureTask();
    }
    else {
        textCuts.textContent = currentCutsCount + '/' + requiredCutsCount;
        textFigures.textContent = currentFiguresCount + '/' + requiredFiguresCount;
    }

}

function svgFigureMouseUpHandler(e) {

    if (isMouseHoldOnSvg && isGameRunning) {
        isMouseHoldOnSvg = false;

        // Get svg container
        let target = e.target;
        while (target.id != "svg-figure") {
            target = target.parentNode;
        }

        // Cursor coordinates realtive to container
        const containerRect = target.getBoundingClientRect();
        const cursorRelativeX = e.clientX - containerRect.x;
        const cursorRelativeY = e.clientY - containerRect.y;

        // If line intersects with polygon, then place it and save intersection points as cut
        // Otherwise, remove line
        const lines = document.querySelectorAll("#svg-figure>line");
        let line = lines[lines.length - 1];
        if (polygonVertices.length != 0) {

            // Place line
            line.setAttribute("x2", cursorRelativeX);
            line.setAttribute("y2", cursorRelativeY);

            // Remove line if it doesn't intersect with any figure
            let intersectionPoints = [];
            let segment1, segment2;
            segment1 = {
                "x1": parseInt(line.getAttribute("x1")),
                "y1": parseInt(line.getAttribute("y1")),
                "x2": parseInt(line.getAttribute("x2")),
                "y2": parseInt(line.getAttribute("y2"))
            };
            for (let i = 0; i < polygonVertices.length; i++) {

                // Polygon segment
                if (i == polygonVertices.length - 1) {
                    segment2 = {
                        "x1": polygonVertices[i]["x"],
                        "y1": polygonVertices[i]["y"],
                        "x2": polygonVertices[0]["x"],
                        "y2": polygonVertices[0]["y"]
                    };
                }
                else {
                    segment2 = {
                        "x1": polygonVertices[i]["x"],
                        "y1": polygonVertices[i]["y"],
                        "x2": polygonVertices[i + 1]["x"],
                        "y2": polygonVertices[i + 1]["y"]
                    };
                }

                // If line intersects with polygon segment, then add to array
                const p = getIntersectionPoint(segment1, segment2);
                if (p != null) {
                    intersectionPoints.push(p);
                }

            }

            // If line intersects with polygon, then add intersection points to cuts array
            if (intersectionPoints.length != 2) {
                line.remove();
            }
            else {
                currentCutsPoints.push({
                    "x1": intersectionPoints[0]["x"],
                    "y1": intersectionPoints[0]["y"],
                    "x2": intersectionPoints[1]["x"],
                    "y2": intersectionPoints[1]["y"],
                })
                updateFigureTaskState();
            }

        }
        else {
            line.remove();
        }
    }
};


function svgFigureMouseMoveHandler(e) {
    if (isMouseHoldOnSvg && isGameRunning) {
        let target = e.target;
        while (target.id != "svg-figure") {
            target = target.parentNode;
        }

        const lines = document.querySelectorAll("#svg-figure>line");
        let line = lines[lines.length - 1];
        const containerRect = target.getBoundingClientRect();
        const cursorRelativeX = e.clientX - containerRect.x;
        const cursorRelativeY = e.clientY - containerRect.y;
        line.setAttribute("x2", cursorRelativeX);
        line.setAttribute("y2", cursorRelativeY);
    }

};

document.getElementById("svg-figure").addEventListener("mousedown", svgFigureMouseDownHandler);
document.getElementById("svg-figure").addEventListener("mouseup", svgFigureMouseUpHandler);
document.getElementById("svg-figure").addEventListener("mousemove", svgFigureMouseMoveHandler);


// Page navigation methods

function pageChangeHandler(fromPageId, toPageId) {
    if (fromPageId == "page-difficulty" && toPageId == "page-figures") {
        startGame();
    }
    else if (fromPageId == "page-figures" && toPageId != "page-gameover") {
        clearGame();
    }
}

function goToPage(pageId) {
    let currentPage = document.getElementById(currentPageId);
    let nextPage = document.getElementById(pageId);
    if (currentPage != null) {
        currentPage.style.visibility = "hidden";
    }
    nextPage.style.visibility = "visible";

    pageChangeHandler(currentPageId, pageId);

    window.history.pushState(pageId, "");
    currentPageId = pageId;
}

// Logout button
var buttonLogoutCollection = document.getElementsByClassName("button-logout");
for (let i = 0; i < buttonLogoutCollection.length; i++) {
    buttonLogoutCollection[i].addEventListener("click", (e) => {
        goToPage("page-authorization");
    });
}

// Back button
var buttonBackCollection = document.getElementsByClassName("button-back");
for (let i = 0; i < buttonBackCollection.length; i++) {
    buttonBackCollection[i].addEventListener("click", (e) => {
        goToPage("page-home");
    });
}

// Go to previous page
window.addEventListener('popstate', (e) => {
    goToPage(e.state);
});

// Play button
document.getElementById("button-play").addEventListener("click", (e) => {
    goToPage("page-difficulty");
});

// Leaderboard button
document.getElementById("button-leaderboard").addEventListener("click", (e) => {
    updateLeaderboard();
    goToPage("page-leaderboard");
});

// Easy difficulty button
document.getElementById("button-easy").addEventListener("click", (e) => {
    setDifficulty("easy");
    goToPage("page-figures");
});

// Normal difficulty button
document.getElementById("button-normal").addEventListener("click", (e) => {
    setDifficulty("normal");
    goToPage("page-figures");
});

// Hard difficulty button
document.getElementById("button-hard").addEventListener("click", (e) => {
    setDifficulty("hard");
    goToPage("page-figures");
});

// Retry button
document.getElementById("button-retry").addEventListener("click", (e) => {
    goToPage("page-difficulty");
});

// Home button
document.getElementById("button-home").addEventListener("click", (e) => {
    goToPage("page-home");
});

goToPage("page-authorization");
